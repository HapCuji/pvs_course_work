/*Решение
Введение в многопоточность

В статье рассматриваются методы синхронизации потоков одного или нескольких процессов. Все методы основаны на создании специальных объектов синхронизации. Эти объекты характеризуются состоянием. Различают сигнальное и несигнальное состояние. В зависимости от состояния объекта синхронизации один поток может узнать об изменении состояния других потоков или общих (разделяемых) ресурсов.

Небольшое замечание: функция _beginthread, используемая в примерах, может быть заменена соответствующим эквивалентом MFC (AfxBeginThread) или аналогичной в других диалектах языка С.

Несинхронизированные потоки

Первый пример иллюстрирует работу с несинхронизированными потоками. Основной цикл, который является основным потоком процесса, выводит на экран содержимое глобального массива целых чисел. Поток, названный "Thread", непрерывно заполняет глобальный массив целых чисел.

C
Выделить код

*/
  #include <process.h>
  #include <stdio.h>
  
  int a[ 5 ];
  
  void Thread( void* pParams )
  { int i, num = 0;
  
    while ( 1 )
    { 
       for ( i = 0; i < 5; i++ ) a[ i ] = num;
       num++;
    }
  }
  
  int main( void )
  { 
     _beginthread( Thread, 0, NULL );
  
     while( 1 )
        printf("%d %d %d %d %d\n", 
               a[ 0 ], a[ 1 ], a[ 2 ],
               a[ 3 ], a[ 4 ] );
  
   return 0;
  }
/*
Как видно из результата работы процесса, основной поток (сама программа) и поток Thread действительно работают параллельно (красным цветом обозначено состояние, когда основной поток выводит массив во время его заполнения потоком Thread):

81751652 81751652 81751651 81751651 81751651
81751652 81751652 81751651 81751651 81751651
83348630 83348630 83348630 83348629 83348629
83348630 83348630 83348630 83348629 83348629
83348630 83348630 83348630 83348629 83348629

Запустите программу, затем нажмите "Pause" для остановки вывода на дисплей (т.е. приостанавливаются операции ввода/вывода основного потока, но поток Thread продолжает свое выполнение в фоновом режиме) и любую другую клавишу для возобновления выполнения.

Критические секции

А что делать, если основной поток должен читать данные из массива после его обработки в параллельном процессе? Одно из решений этой проблемы - использование критических секций.

Критические секции обеспечивают синхронизацию подобно мьютексам (о мьютексах см. далее) за исключением того, что объекты, представляющие критические секции, доступны в пределах одного процесса. События, мьютексы и семафоры также можно использовать в "однопроцессном" приложении, однако критические секции обеспечивают более быстрый и более эффективный механизм взаимно-исключающей синхронизации. Подобно мьютексам объект, представляющий критическую секцию, может использоваться только одним потоком в данный момент времени, что делает их крайне полезными при разграничении доступа к общим ресурсам. Трудно предположить что-нибудь о порядке, в котором потоки будут получать доступ к ресурсу, можно сказать лишь, что система будет "справедлива" ко всем потокам.

C
Выделить код

  #include <windows.h>
  #include <process.h>
  #include <stdio.h>
  */
  CRITICAL_SECTION cs;
  int a[ 5 ];
  
  void Thread( void* pParams )
  {
    int i, num = 0;
  
    while ( TRUE )
    {
       EnterCriticalSection( &cs );
       for ( i = 0; i < 5; i++ ) a[ i ] = num;
       LeaveCriticalSection( &cs );
       num++;
    }
  }
  
  int main( void )
 
  { 
    InitializeCriticalSection( &cs );
    _beginthread( Thread, 0, NULL );
  
    while( TRUE )
    {
       EnterCriticalSection( &cs );
       printf( "%d %d %d %d %d\n", 
               a[ 0 ], a[ 1 ], a[ 2 ],
               a[ 3 ], a[ 4 ] );
       LeaveCriticalSection( &cs );
    }
    return 0;
  }
/*
Мьютексы (взаимоисключения)

Мьютекс (взаимоисключение, mutex) - это объект синхронизации, который устанавливается в особое сигнальное состояние, когда не занят каким-либо потоком. Только один поток владеет этим объектом в любой момент времени, отсюда и название таких объектов - одновременный доступ к общему ресурсу исключается. Например, чтобы исключить запись двух потоков в общий участок памяти в одно и то же время, каждый поток ожидает, когда освободится мьютекс, становится его владельцем и только потом пишет что-либо в этот участок памяти. После всех необходимых действий мьютекс освобождается, предоставляя другим потокам доступ к общему ресурсу.

Два (или более) процесса могут создать мьютекс с одним и тем же именем, вызвав метод CreateMutex. Первый процесс действительно создает мьютекс, а следующие процессы получают хэндл уже существующего объекта. Это дает возможность нескольким процессам получить хэндл одного и того же мьютекса, освобождая программиста от необходимости заботиться о том, кто в действительности создает мьютекс. Если используется такой подход, желательно установить флаг bInitialOwner в FALSE, иначе возникнут определенные трудности при определении действительного создателя мьютекса.

Несколько процессов могут получить хэндл одного и того же мьютекса, что делает возможным взаимодействие между процессами. Вы можете использовать следующие механизмы такого подхода:

* Дочерний процесс, созданный при помощи функции CreateProcess может наследовать хэндл мьютекса в случае, если при его (мьютекса) создании функией CreateMutex был указан параметр lpMutexAttributes.
* Процесс может получить дубликат существующего мьютекса с помощью функции DuplicateHandle.
* Процесс может указать имя существующего мьютекса при вызове функций OpenMutex или CreateMutex.

Вообще говоря, если вы синхронизируете потоки одного процесса, более эффективным подходом является использование критических секций.

C
Выделить код

  #include <windows.h>
  #include <process.h>
  #include <stdio.h>
  */
  HANDLE hMutex;
  int a[ 5 ];
  
  void Thread( void* pParams )
  { 
     int i, num = 0;
  
     while ( TRUE )
     { 
        WaitForSingleObject( hMutex, INFINITE );
        for ( i = 0; i < 5; i++ ) a[ i ] = num;
        ReleaseMutex( hMutex );
        num++;
     }
  }
  
  int main( void )
  {
     hMutex = CreateMutex( NULL, FALSE, NULL );
     _beginthread( Thread, 0, NULL );
  
     while( TRUE )
 
     {
        WaitForSingleObject( hMutex, INFINITE );
        printf( "%d %d %d %d %d\n", 
                a[ 0 ], a[ 1 ], a[ 2 ],
                a[ 3 ], a[ 4 ] );
        ReleaseMutex( hMutex );
     }
     return 0;
  }
/*
События

А что, если мы хотим, чтобы в предыдущем примере второй поток запускался каждый раз после того, как основной поток закончит печать содержимого массива, т.е. значения двух последующих строк будут отличаться строго на 1?

Событие - это объект синхронизации, состояние которого может быть установлено в сигнальное путем вызова функций SetEvent или PulseEvent. Существует два типа событий:

Событие с ручным сбросом - Это объект, сигнальное состояние которого сохраняется до ручного сброса функцией ResetEvent. Как только состояние объекта установлено в сигнальное, все находящиеся в цикле ожидания этого объекта потоки продолжают свое выполнение (освобождаются).

Событие с автоматическим сбросом - Объект, сигнальное состояние которого сохраняется до тех пор, пока не будет освобожден единственный поток, после чего система автоматически устанавливает несигнальное состояние события. Если нет потоков, ожидающих этого события, объект остается в сигнальном состоянии.

События полезны в тех случаях, когда необходимо послать сообщение потоку, сообщающее, что произошло определенное событие. Например, при асинхронных операциях ввода и вывода из одного устройства, система устанавливает событие в сигнальное состояние когда заканчивается какая-либо из этих операций. Один поток может использовать несколько различных событий в нескольких перекрывающихся операциях, а затем ожидать прихода сигнала от любого из них.

Поток может использовать функцию CreateEvent для создания объекта события. Создающий событие поток устанавливает его начальное состояние. В создающем потоке можно указать имя события. Потоки других процессов могут получить доступ к этому событию по имени, указав его в функции OpenEvent.

Поток может использовать функцию PulseEvent для установки состояния события в сигнальное и затем сбросить состояние в несигнальное после освобождения соответствующего количества ожидающих потоков. В случае объектов с ручным сбросом освобождаются все ожидающие потоки. В случае объектов с автоматическим сбросом освобождается только единственный поток, даже если этого события ожидают несколько потоков. Если ожидающих потоков нет, PulseEvent просто устанавливает состояние события в несигнальное.

C
Выделить код
  #include <windows.h>
  #include <process.h>
  #include <stdio.h>
  */
  HANDLE hEvent1, hEvent2;
  int a[ 5 ];
  
  void Thread( void* pParams )
  {
     int i, num = 0;
 
     while ( TRUE )
     {
        WaitForSingleObject( hEvent2, INFINITE );
        for ( i = 0; i < 5; i++ ) a[ i ] = num;
        SetEvent( hEvent1 );
        num++;
     }
  }
  
  int main( void )
  {
     hEvent1 = CreateEvent( NULL, FALSE, TRUE, NULL );
     hEvent2 = CreateEvent( NULL, FALSE, FALSE, NULL );
  
     _beginthread( Thread, 0, NULL );
  
     while( TRUE )
     { 
        WaitForSingleObject( hEvent1, INFINITE );
        printf( "%d %d %d %d %d\n", 
                a[ 0 ], a[ 1 ], a[ 2 ],
                a[ 3 ], a[ 4 ] );
        SetEvent( hEvent2 );
     }
     return 0;
  }


/*
В семействах ОС Windows — каждая программа запускает один процесс выполнения, в котором находится как минимум один поток (нить). 
В процессе может находиться множество потоков, между которыми делится процессорное время. 
Один процесс не может напрямую обратиться к памяти другого процесса, а потоки же разделяют одно адресное пространство одного процесса.  
То есть в Windows — процесс это совокупность потоков.

В Linux же немного по-другому. Сущность процесса такая же, как и в Windows — это исполняемая программа со своими данными. 
Но вот поток в Linux является отдельным процессом (можно встретить название как «легковесный процесс», LWP).
 Различие такое же — процесс отдельная программа со своей памятью, не может напрямую обратиться к памяти другого процесса, 
 а вот поток, хоть и отдельный процесс, имеет доступ к памяти процесса-родителя [2]. 
 LWP процессы создаются с помощью системного вызова clone() с указанием определенных флагов.

Но также имеется такая вещь, которая называется «POSIX Threads» — библиотечка стандарта POSIX, 
которая организует потоки (они же нити) внутри процесса. 
Т.е тут уже распараллеливание происходит в рамках одного процесса.
*/


/*
идея для репетиторства
если мотивировать успешную сдачу экзаменов материально
отдавая после сдачи часть денег ученику
:: допустим чтобы поступить куда он хочет
нужно минимум 230 балов
если он считает что сдает русский на 70+
математику (если не знает подтянет) на 70+
то по информатике ему надо набрать 90+
это дофига.

поскольку нужен запас будем брать 
75+ русский == 5 (так как от меня не зависит)
75+ мат == 5 (так как есть с6)
95+ информатика == 5 (вообще я хотел min+10 делать но хз)

короче если сдает на 95 - это 100% от суммы накопленной от занятий (т.е. если год ~20 недель это 20*500==10_000р), кажется жто не так плохо.
если 85...95 (минус 10 баллов) это 75%
если 80..85 (минус 15 .. 10 балов) это 50%
меньше считаю не заслужил (по обстоятельствам, по идее тут я наложал так что и мне следовало бы вернуть бабосы (ради справедливости), но хз как, мб ни тебе ни мне)
* но если поступит куда хотел то верну 40-50% (все таки успех)
** мне кажется 10р норм мотивация для ученика



*/